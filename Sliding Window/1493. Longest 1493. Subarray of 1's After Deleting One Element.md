## Problem ##
https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/?envType=study-plan-v2&envId=leetcode-75

## Problem Description ##
> Given a binary array `nums`, you should delete exactly one element from it.
>
> Return the size of the longest non-empty subarray containing only `1`s in the resulting array.
>
> Return `0` if there is no such subarray.

## First Solution - Python3 ##
```python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        l = 0
        zeros = 0
        best = 0

        for r, x in enumerate(nums):
            # each window at most 1 zero
            if x == 0:
                zeros += 1

            while zeros > 1:
                if nums[l] == 0:
                    zeros -= 1
                l += 1
            
            # must delete one element
            best = max(best, (r - l + 1) - 1)
        
        return best

```

### Explanation

We use a sliding window `[l ... r]`.

Inside the window, we allow **at most one `0`**.

- Why? Because we are allowed to delete exactly one element.

- If there is one `0` in the window, we can delete that `0`, and the rest are all `1`s.

Steps:

1. Move `r` from left to right.

2. If `nums[r]` is `0`, increase `zeros`.

3. If `zeros > 1`, the window has too many zeros, so move `l` right until `zeros <= 1`.

4. For each valid window, the number of `1`s we can keep after deleting one element is:

   - `window_length - 1`  (because we must delete one element)

   - `window_length = (r - l + 1)`

So we update:
 `best = max(best, (r - l + 1) - 1)`

This also correctly handles the case where the window has no zero (all ones):
 we still must delete one element, so we subtract 1.
