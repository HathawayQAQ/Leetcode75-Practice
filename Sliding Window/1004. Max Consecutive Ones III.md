## Problem ##
https://leetcode.com/problems/max-consecutive-ones-iii/description/?envType=study-plan-v2&envId=leetcode-75

## Problem Description ##
> Given a binary array `nums` and an integer `k`, return the maximum number of consecutive `1`s in the array if you can flip at most `k` `0`s.

## First Solution ##
```python
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        l = 0
        zeros = 0
        best = 0

        for r, x in enumerate(nums):
            # each window at most k zero
            if x == 0:
                zeros += 1

            while zeros > k:
                if nums[l] == 0:
                    zeros -= 1
                l += 1
            
            best = max(best, (r - l + 1))
        
        return best
```

### Explanation

This problem is **very similar to the previous question** [1493. Longest Subarray of 1s After Deleting One Element](<https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/?envType=study-plan-v2&envId=leetcode-75>).

The idea is the same: use a sliding window `[l ... r]` and count how many `0`s are inside.

- In the previous problem, we allowed **at most 1 zero** (because we can delete one element).
- In this problem, we allow **at most `k` zeros** (because we can flip at most `k` zeros to ones).

Steps:

1. Move `r` to the right.
2. If `nums[r]` is `0`, increase `zeros`.
3. If `zeros > k`, move `l` right until `zeros <= k`.
4. Now the window is valid, update the answer with the window length: `r - l + 1`.
