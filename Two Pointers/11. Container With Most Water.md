## Problem ##
https://leetcode.com/problems/container-with-most-water/description/?envType=study-plan-v2&envId=leetcode-75

## Problem Description ##
> You are given an integer array `height` where `height[i]` represents the height of a vertical line at position `i`.
>
> Choose two lines that together with the x-axis form a container, such that the container contains the most water.
>
> Return the maximum amount of water a container can store.

## First Solution - Python3 ##
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # area = (j - i) * min(height[i], height[j])
        l = 0 # leftmost
        r = len(height) - 1 # rightmost
        best = 0

        while l < r:
            h = min(height[l], height[r])
            best = max(best, h * (r - l)) # calculate the best rn

            # only move the lower one
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        
        return best
```

### Explanation

We want to pick two lines to hold the most water.

The water area depends on:

- **Width** = distance between the two lines = `(r - l)`

- **Height** = the **shorter** line, because water leaks over the shorter side
   so `min(height[l], height[r])`

So: `area = (r - l) * min(height[l], height[r])`

**Two pointers idea:**

- Start with the widest container: left pointer at the start, right pointer at the end.

- Compute the area, update the best answer.

- Then move **only the shorter side**:

  - If left is shorter, move left rightward (`l += 1`)

  - If right is shorter (or equal), move right leftward (`r -= 1`)

Why move the shorter side?

- The shorter side is limiting the height.

- If we move the taller side, the height limit doesn't improve, and width becomes smaller â†’ not helpful.

- Moving the shorter side is the only chance to find a taller line and maybe get a bigger area.

Keep doing this until `l` meets `r`. The best area found is the answer.

## Improved Solution

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        l, r = 0, len(height) - 1
        best = 0

        while l < r:
            best = max(best, (r - l) * min(height[l], height[r]))

            if height[l] < height[r]:
                l += 1
            else:
                r -= 1

        return best
```
