## Problem ##
https://leetcode.com/problems/determine-if-two-strings-are-close/?envType=study-plan-v2&envId=leetcode-75

## Problem Description ##
> Two strings are considered **close** if you can transform one string into the other using the following operations any number of times:
>
> 1. Swap any two existing characters in the string.  
> 2. Transform every occurrence of one existing character into another existing character, and do the same with the other character  
>    (i.e. swap the character labels globally).
>
> Given two strings `word1` and `word2`, return `true` if `word1` and `word2` are close, otherwise return `false`.

## First Solution ##
```python
from collections import Counter

class Solution:
    def closeStrings(self, word1: str, word2: str) -> bool:
        if len(word1) != len(word2):
            return False

        c1 = Counter(word1)
        c2 = Counter(word2)

        if set(c1.keys()) != set(c2.keys()):
            return False
        
        return sorted(c1.values()) == sorted(c2.values())
```

### Explanation

Two strings are **close** only if all these are true:

**1) Same length**

If the lengths are different, you can never transform one into the other.

**2) Same set of characters**

The characters that appear in `word1` must be exactly the same as the characters that appear in `word2`.
 Operation 2 can only swap/rename characters that already exist, so you cannot create a new character.

Example: `"a"` and `"b"`
 `{a}` is not the same as `{b}` → not possible.

**3) Same multiset of frequencies (ignore which character it is)**

Operation 2 can swap character labels, so only the *frequency pattern* matters.
 That is why we compare `sorted(c1.values())` and `sorted(c2.values())`.

Example:
 `"aabccc"` has counts `{a:2, b:1, c:3}` → frequencies `[2,1,3]`
 `"xxzyyy"` has counts `{x:2, z:1, y:3}` → frequencies `[2,1,3]`
 Same frequency pattern → close.
